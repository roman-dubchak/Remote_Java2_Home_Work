package ru.gb.javatwo.network;

import java.net.Socket;

public interface SocketThreadListener {

    void onSocketStart(SocketThread thread, Socket socket);
    void onSocketStop(SocketThread thread);

    void onSocketReady(SocketThread thread, Socket socket);
    void onReceiveString(SocketThread thread, Socket socket, String msg);

    void onSocketException(SocketThread thread, Exception exception);
}

/*
* Вопрос общий: нормально ли, что вкуривая происходящее, я понимаю, что такое сам я не напишу точно?

Непонятна логика вызова метода sendToAllAuthorizedClients в таком контексте: sendToAllAuthorizedClients(Common.getTypeBroadcast("Server", nickname + " connected")); Мне почему-то казалось, что метод рассылки должен зависеть от типа сообщения, а тут получается, что мы в любом случае рассылаем его всем, и при этом еще говорим, что оно широковещательное
Отправка сообщений у меня в голове почему-то вообще закольцевалась: Клиент (STL) вызывает метод sendMessage у SocketThread (ST), тот грузит его в out, ST со стороны сервера достает сообщение из in и вызывает у сервера (тоже STL) метод onReceiveString. Тот в свою очередь вызывает метод sendToAllAuthorizedClients (в любом случае - при авторизации или отправке сообщения). А в методе sendToAllAuthorizedClients вызывается снова sendMessage у клиентского SocketThread. И я не могу выйти из этого круга...Скорее всего, я где-то путаю, какой тред куда отправляет сообщения PS. На момент сдачи кода я уже "раскольцевался", но вопрос решил оставить
1.в классе Сommon используются только методы по работе с чатом с точки зрения сообщений общих и авторизации,можно ли было вынести getAuthAccept, getAuthDenied? на мой взгляд они не совсем ложаться на этот класс
2.Можно ли было DATE_FORMAT вынести из ChatServer в common? это ведь может понадобиться не только на сервере
3.Напомните пожалуйста почему onChatServerMessage вынесли в интерфейс?
4.По SQLClient -вопросов нет,давно работаю с JDBC
5.Что делает log.setCaretPosition(log.getDocument().getLength()) в методе onChatServerMessage?
6.В каком случае нужно рассширять функциональность класса,а не дополнять его новыми методами?

//////////////////////////////////////////////////
Вопрос к уроку:
String login = tfLogin.getText();
String password = new String(tfPassword.getPassword());
почему во втором случае мы инициализируем переменную новым объектом, а не как в предыдущей строке?
////////////////////////////////////////////////////
Хотелось бы, чтобы вы прошилсь по таким темам как: внутренние, внешние, локальныы классы, их взаимоотношения, видимость переменных, создание объектов. Есть ли какие-то ограничения на использование модификаторов доступа при работе с ними? Примеры их применения в реальных проектах (понимаю, что они применяются там, где нам требуется их применение, но хотелось бы как-то больше жизненных примеров).
//////////////////////////////////////////////////
Хотя бы тезисно, о перечислениях: их конструкторах, их модификаторах доступа.
/////////////////////////////////////////////////
В литературе встречаю вот такие формулировки: "принимает объект типа T, Predicate<T>
Consumer<T> Function<T,R>" по анологии понимаю, что это что-то типа как HashMap<K,V>, где К - это key, а V - это value. А <Т> и <R>, что это за типы?
//////////////////////////////////////////////////
На что влияет коэффициент loadFactor у HashMap?

При дисконекте получаю EOFException в SocketThread. После вызова метода close() у сокета клиента, вызывается socket.close() в SocketThread и в строке String msg = in.readUTF(); генерируется как раз End Of File, т.к. сокет уже закрыт и у него нет InputStream'a. Правильно ли я это понимаю и как правильно обработать это исключение или избавится от него. + сейчас в ClientGUI генерится SocketException, его тоже нужно обработать как то по другому?
1) для чего нужен класс SqlClient? Я не нашла ни одного экземпляра данного класса
2) SQLite JBDC это "посредник" между нашим java-кодом и базой SQL?
3) private Vector<SocketThread> clients = new Vector<>(); Почему именно Вектор? Единственная его особенность, которую мне удалось загуглить- синхронизация. Из-за неё?
Весь код не выглядит сложным, но в голове очень трудно построить как всё взаимодействует. Вы говорили о том, что можно разрисосвывать взаимодейтсвие классов на бумаге, но с чего начинать? Какой класс выбирать в качестве отправной точки?
Единственное, что по большему счету осталось непонятным, это архитектура и взаимодействие модулей.

Есть пробелы в понимании "работы" интерфейсов. Часто ли методы в интефейсах "пустые"?
Почему методы SqlClient synchronized? Чтобы не перепутались данные из БД? по одному login не прилетел другой user?
Как мы в onSocketAccepted заменили SocketThread на ClientThread? Расскажите про приведение типа SocketThread в ClientThread в строке ClientThread client = (ClientThread) clients.get(i);

*enum помогает в определении своих собственных типов данных. Как это происходит?
*Наименования исключений. Как я понял есть определенные наименования Exception (зашитые разработчиками java), но возможно создавать свои Exception(ы). При этом необходимо описывать их в отдельном классе. Все правильно?
**SwingUtilities.invokeLater предназначена для запуска асинхронной операции. Она сохраняет действие (Runnable), и запускает его на одной из следующих итераций цикла сообщений. Можно ли SwingUtilities.invokeLater заменить разбивкой многопоточной операции?

* */